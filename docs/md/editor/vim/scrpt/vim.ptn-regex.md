
# ptn regex


## 位置指定

位置指定系 はすべて 幅ゼロ でマッチします

```
^    行頭 に マッチ
$    行末 に マッチ
\%^  テキストの 先頭 にマッチ
\%$  テキストの 末尾 にマッチ

\<   ワードの直前にマッチ
\>   ワードの直後にマッチ
     \<var\> は var hoge=1 にマッチするが variable にはマッチしない

\zs  マッチの開始地点を設定する
     これより前は幅ゼロ扱いでマッチに含まない
     後読みの代わりに使える
     複数マッチした場合は一番最後が有効
\ze  マッチの終了地点を設定する
     これより後は幅ゼロ扱いでマッチに含まない
     先読みの代わりに使える
     複数マッチした場合は一番最後が有効
```


### vimの状態や座標に関係するもの

```
\%V        ビジュアルモードの範囲内にマッチ
\%Vfoo\%V  選択範囲内の foo にマッチ
\%V        でマッチの前後を挟むのが基本的な使い方

\%# はカーソル位置にマッチ
\k\%#\k はカーソル位置の単語
\s*\%#\s* はカーソル位置の空白文字の連続にマッチ

\%'m   マークm      に マッチ
\%<'m  マークm の前 に マッチ
\%>'m  マークm の後 に マッチ

\%23    23行目        の行 に マッチ
\%<23   23行目 より上 の行 に マッチ
\%>23   23行目 より下 の行 に マッチ

\%23c   23列目
\%<23c  23列目 より前 の列 に マッチ
\%>23c  23列目 より後 の列 に マッチ

\%23v   23列目 の 表示列             に マッチ
\%<23v  23列目 の 表示列 より前 の列 に マッチ
\%>23v  23列目 の 表示列 より後 の列 に マッチ
```


## 文字クラス

```
[a-z]   a - z の文字にマッチ     preg と同じ
[^a-z]  a - z 以外の文字にマッチ preg と同じ

.   すべての文字にマッチ  改行以外
\s  空白文字にマッチ      改行以外

\d  [0-9]        と同じ  10進数 に使われる文字
\x  [0-9A-Fa-f]  と同じ  16進数 に使われる文字
\o  [0-7]        と同じ   8進数 に使われる文字
\w  [0-9A-Za-z_] と同じ  単語   に使われる文字
\h  [A-Za-z_]    と同じ  \wから数字を除いたもの 単語の先頭文字
\a  [A-Za-z]     と同じ  英字
\l  [a-z]        と同じ  英字 の 小文字
\u  [A-Z]        と同じ  英字 の 大文字

\S, \D, \X, \O, \W, \H, \A, \L, \U はそれぞれ 改行以外の文字, 数字以外の文字, ... にマッチする

\_+↑  `< wip:ref org home page`
      文字にマッチ          改行を含む
\_.   すべての文字にマッチ  改行を含む  Perlのs修飾子を付けた状態みたいな感じ
\_s   改行を含む空白文字にマッチ

\_d, \_x, \_o, \_w, \_h, \_a, \_l, \_u, \_S, \_D, \_X, \_O, \_W, \_H, \_A, \_L, \_U とかも同様

\_[a-z]     [a-z] と 改行文字 にマッチ
\%d123      10進数で指定した文字にマッチ (最大値=255)
\%o40        8進数で指定した文字にマッチ (最大値=377=255)
\%x2a       16進数で指定した文字にマッチ (最大値=ff=255)
\%u20AC     16進数で指定した文字にマッチ (4桁まで)
\%U1234abcd 16進数で指定した文字にマッチ (8桁まで)
```


### 文字クラス  key word

```
[:alnum:]
[:alpha:]
[:backspace:]
[:blank:]
[:cntrl:]
[:digit:]
[:escape:]
[:graph:]
[:lower:]
[:print:]
[:punct:]
[:return:]
[:space:]
[:tab:]
[:upper:]
[:xdigit:]
```


## 繰り返し

```
a*   0回以上の a の繰り返しにマッチ (最長一致)
a+   単に a+ という文字列にマッチ
a\+  1回以上の a の繰り返しにマッチ (最長一致)
a?   単に a? という文字列にマッチ
a\?  0または1個の a にマッチ
l\=  0または1個の a にマッチ (\? と基本同じだが \? は後方検索で使えない)
```


## 繰り返し 回数 指定

### 最長一致

```
a\{n}     n 回              の a の繰り返し
a\{n,m}   n 回以上 m 回以下 の a の繰り返し
a\{,m}    0 回以上 m 回以下 の a の繰り返し
a\{n,}    n 回以上          の a の繰り返し
a\{,}     0 回以上          の a の繰り返し  a* と同じ
```

### 最短一致

```
a\{-n}    n 回              の a の繰り返し  - の有無で違いはない
a\{-n,}   n 回以上          の a の繰り返し
a\{-n,m}  n 回以上 m 回以下 の a の繰り返し
a\{-,m}   0 回以上 m 回以下 の a の繰り返し
a\{-,}    0 回以上          の a の繰り返し
a\{-,1}   0 か 1 個         の a
```


## \@> ... 強欲な量指定子 直前のパターンが強欲にマッチするようになる

Perl の (?>pattern) と似ている

```
\(a*\)\@>b  aaab にマッチするが、\(a*\)\@>ab は aaab に決してマッチしない
            なぜなら \(a*)\@> が先に aaa まで取ってしまい バックトラックもしないので
            次の文字は b となり、後が ab になることはないため
```


## グルーピング系

```
(foo|bar)       (foo|bar) という文字列にマッチ
\(foo\|bar\)    foo か bar にマッチ
                部分正規表現に一致した文字列は \1 や \2 で後方参照できる
\%(foo\|bar\)   foo か bar にマッチ
                \(foo\|bar\) と基本的に同じだが後方参照を作らないので その分高速
                (『pregの(?:foo|bar)』と同じ)
\%z(foo\|bar\)  foo か bar にマッチ
                syntaxコマンドのstart=オプションの中でのみ使用可能で、
                部分正規表現に一致した文字列は同コマンドのend=オプションの中で \z1 や \z2 で参照できる
a\%[bcd]        a/ab/abc/abcd にマッチ
                ad にはマッチしない
                (Perlのa(b(cd?)?)?みたいなイメージ)
```


## 文字エスケープ

```
\e  <Esc>    にマッチ
\t  <Tab>    にマッチ
\r  <CR>     にマッチ
\b  <BS>     にマッチ
\n  改行文字 にマッチ
```


## 先読み 後読み

```
\@=  肯定先読み 
     foo\%(bar\)\@= は直後にbarがあるfooにマッチする、
     bar部分はゼロ幅扱いでマッチに含まない 
     (『Perlの(?=bar)』と同じ)

     foo\%(bar\)\@=  は \ze を使って、foo\zebar と書くことも出来る

\@!  否定先読み 
     foo\%(bar\)\@! は直後にbarがないfooにマッチする (『Perlの(?!bar)』と同じ)
     否定先読みは高コストなので出来るだけ使わないほうが良い

\@<=  肯定後読み 
      \%(foo\)\@<bar は直前にfooがあるbarにマッチする、
      foo部分はゼロ幅扱いでマッチに含まれない
      (『Perlの(?<=pattern)』と基本同じだが、vimでは量指定子も使える)
      \@123<= とすると \@<= と基本同じだが、パフォーマンスのために遡ってチェックするバイト数を制限できる

      \%(foo\)\@<bar は \zs を使って foo\zsbar と書くことも出来る

      否定後読みの対象パターンが後方参照を作るとき、
      正規表現エンジンのバージョンによってその挙動に違いが出ることがあるらしくポータビリティを考えると 
      \zs を使って書いたほうが良いらしい

\@<!  否定後読み 
      \%(foo\)\@<!bar は直前にfooがないbarにマッチする
      (『Perlの(?<!pattern)』と基本同じだが、vimでは量指定子も使える)
      \@123<! とすると \@<! と基本同じだが、パフォーマンスのために遡ってチェックするバイト数を制限できる
      否定後読みは高コストなので出来るだけ範囲制限をかけるようにした方が良い

      心の声 : vim の先読み後読みの \@XX 系パターンは記号自体がゴツいのとpregと違って記号を後置するのが慣れないので、
      \zs と \ze で代替出来るケースでは後者を使う方が個人的には好みです 
      ただ、他人の書いたコードを読むと \@XX も結構出てくるので読めないと困るので
      その確認用にまとめ直しはじめたのがこのエントリです
```


## 修飾子

```
\c  \c をパターンに含めるとパターン全体で大文字と小文字の違いが無視されるようになる
    但し \w とかの文字クラスには影響しない
\C  \C をパターンに含めるとパターン全体で大文字と小文字の違いが区別されるようになる
    但し \w とかの文字クラスには影響しない

\m  それ以降パターンを magic        にする
\M  それ以降パターンを nomagic      にする
\v  それ以降パターンを very magic   にする
\V  それ以降パターンを very nomagic にする
```


## 合成文字関連

詳細は各自でドキュメントを確認

```
\Z  をパターンに含めるとパターン全体で合成文字が無視される
    càt という文字列に対して cat ではマッチしないが \Zcat や cat\Z とするとマッチできる

\%C は直前のパターンについてのみ合成文字を無視する
    aà aa àà という文字列に対して、aa\%C は aà や aa の部分にはマッチするが àà にはマッチしない
```


## その他

```
~ は最後に置換された文字列にマッチする
```



